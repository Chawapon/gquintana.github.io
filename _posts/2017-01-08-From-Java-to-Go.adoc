= From Java to Go

:hp-tags: 7li7w, go
:hp-image: /images/logos/golang.png
:source_dir: ../sources/2017-01-15-From-Java-to-Go
:published_at: 2017-01-08

This is the second episode of my _7 languages in 7 weeks_ series of blog posts.
After link:2017-01-08-From-Java-to-Ruby.html[Ruby] a language which is more than 20 years old,
I tried Go a more recent language: it was created in 2009.
Go gained in traction thanks to the Docker ecosystem:
Docker daemon, Kubernetes, Traefik are mostly developed in Go.

== The good

=== Simple to learn

Even if the language is pretty recent, there are many resources to learn Go.
The first one I stumbled upon was https://tour.golang.org/[Tour of Go],
it allows to discover the Go features and test them online.
You can run the web server locally if you want to learn Go in a train or in a plane.
It has been translated in many languages.

I also tried the https://github.com/cdarwin/go-koans[Go Koans],
but the tests are less detailed and progressive than Ruby Koans.
It took me an evening to complete these exercises.

There are several free e-books to get started with Go:

* http://www.golang-book.com/books/intro[Introduction to Programming in Go] by Caleb Doxsey
* http://openmymind.net/The-Little-Go-Book/[The Little Go Book] by Karl Seguin
* http://www.golangbootcamp.com/[Go BootCamp] by Matt Aimonetti

Go is mostly simple to grasp because there are few concepts.
The Go Lang spec is less 100 pages long.

However the "Go" name is not SEO friendly, you'd better google "GoLang" instead.

=== Extensive tooling

As soon as you've installed Go and without extra steps, you can:

* *Get* libraries (Go packages) with a sort of package manager
* *Format* code to stick to Go formatting rules
* *Compile* code and link dependencies.
  Go doesn't allow dynamic linking.
  I was amazed to see how fast it was to compile a simple app and run it.
* *Run* unit tests.
  Go provides a unit testing package, sadly it's not has powerful as other XUnit libraries.
* *Analyze* code and detect suspicious constructs.
* *Search and Read* the base API documentation while being offline.

Sadly, I couldn't find any https://github.com/blindpirate/report-of-go-package-management-tool[official tool] to manage project dependencies
and download them with Go Get.

=== Switch, case, fallthrough

Compare Go's switch statement
[source,go]
----
include::{source_dir}/demo/switch.go[tags=main]
----
With Java's
[source,go]
----
include::{source_dir}/demo/Switch.java[tags=main]
----
The `fallthrough` keyword does the exact opposite of `break`.
This looks like a better default than Java to me,
because most of the time you don't want to run multiple cases.
A missing `break` can raise subtle bugs.

=== Concurrency with channels and routines

First of all, *channels* is a concept used for inter-thread communications.
There are 2 types of channels:

* *Sync channels* are similar to Java's `SynchronousQueue` ,
the producer for the consumer to be ready:
+
[source,go]
----
ch := make(chan string)
----
* *Async channels*: are similar to Java's `ArrayBlockingQueue` ,
the producer waits for a free location to place data,
while the consumer waits for a place filled with data:
+
[source,go]
----
ch := make(chan string, 10)
----

Goroutines are lightweight threads:
[source,go]
----
go doit() // <1>
----
<1> The `doit` function is ran in background

[source,go]
----
include::{source_dir}/demo/concurrency.go[tags=main]
----
<1> Generate and append data in the channel
<2> Pull data from the channel and process it
<3> Run the `multiply` function in a background thread
<4> Run the `generate` function in the main thread.
   I could have placed it in a separate thread as well.

== The bad

=== Error handling

There has been debate about how errors are handled.
I hope not to start a troll with this paragraph.

Prior to explaining my pet peeve with error handling, let me talk about multiple values.
A function can return multiple values but there is no _tuple_ type like Python, Scala...
[source,go]
----
file, err := ioutil.ReadFile("file.txt") // Correct
tuple :=     ioutil.ReadFile("file.txt") // Incorrect
----
I can not assign both values to a single variable.

Now, error handling, in Go there is no Exception concept, you must use multiple return values:

[source,go]
----
include::{source_dir}/demo/error_handling.go[tags=main]
----
<1> Function can raise an error
<2> Raise an error
<3> Return normal result
<4> Propagate the error
<5> Handle normal flow
<6> Handle error flow

To me, this means multiple things

* In the function, I must always return 2 things: `nil+error` (1) or `result+nil` (2).
  I can even return both `result+error`.
* I need to manually propagate the error when it occurs (3).
  Yet the function signature warns me that I may have to do something,
  and I can't hardly forget to deal with it.
* Even if I forward the error, the error doesn't contain any call stack.
  As a result, it's probably harder to debug since you don't know who
  first returned the error (5).
  Hopefully the https://github.com/go-errors/error[go-errors] library may help.
* I can not easily chain function calls (4)
  because I can not write `Order(3).Print()` where `Print` is a function on the type `*Article`.
  I would have to create a function on the multiple type `*Article, error` but
  it's not possible.

=== Pointers

Pointers are not a bad thing per se.
But my C/C++ lectures are far away in my memory, it's not easy to remember the traps and tricks.
Should I pass this variable by reference or by value?

[source,go]
----
include::{source_dir}/demo/pointer.go[tags=main]
----
<1> Happily, I don't have to convert the pointer into value to access the `Price` field.
   I don't have to write `*a.Price` or `a->Price` like in C++
<2> The article price is still 25 because it was passed by value
<3> Here I have to convert the value into a pointer
<4> The article price is now 27 because it was passed by reference
<5> Thanks to the garbage collector, the function can return a pointer to the created article
<6> `p` is a pointer to the created article

=== `make`, `new` and `New`

To create, I mean allocate, something there are several operators depending on the type
and whether you are expecting a pointer or not.
[source,go]
----
include::{source_dir}/demo/make_new.go[tags=main]
----
<1> Create a new struct and initialize its fields
<2> Create a new struct and return a pointer
<3> Create a new array and initialize its elements
<4> Create a new array and return an pointer
<5> Create a new slice
<6> Create a new map and initialize its elements
<7> Create a new map
<8> Create a new struct `Error` and initialize it

The `new` operator always return a pointer, it's like a `malloc` operator in C.
The `make` operator is used to create data structures like slices, maps...
Neither the `new` nor the `make` operators can be passed values,
they are initialized with zeros and empty strings.
The `New` function can contain code to initialize or build something.

I find it a bit disturbing to have different syntaxes to do mostly the same thing.
For a language which aims at simplicity, this is baffling.

=== Harsh compiler

The Go compiler is very strict, this can be good thing at times as it may prevent bugs.
But it can also be bit too picky and annoying at times.
In particular, it doesn't accept unused variables and unused imports.
This is a rather common scenario when you are refactoring or trying something.
The compiler could just warn and skip unused declarations.

To skip a useless import, one can write (notice the underscore):
[source,go]
----
import _ "fmt"
----

Using an IDE (like Jetbrains Gogland) with an intelligent coding assistant
which would fix automatically imports may help.
I also found the https://godoc.org/golang.org/x/tools/cmd/goimports[goimports] command line tool,
but I didn't try it.

== The odd

Characters are called *Runes* in the Go terminology.
But they don't hide any secret magic ;-) .

=== `if` and `for` statements

The `for` statement uses the usual syntax minus the parenthesis:
[source,go]
----
include::{source_dir}/demo/decl_if.go[tags=for]
----

Like in the above `for` construct, the `if` can declare a variable before the mandatory condition:
[source,go]
----
include::{source_dir}/demo/decl_if.go[tags=main]
----
<1> The `dice` variable is visible in the while `if`/`else` bloc.

In the above example, I find the `if` statement to be less readable because
the eye has to remove the `dice` declaration noise.

There is no `while` statement, `for` is the only loop keyword
[source,go]
----
include::{source_dir}/demo/loops.go[tags=main]
----
<1> The `for` with a condition acts as a `while` in most languages
<2> I can not chain `ReadString` and `TrimSpace` functions in single line
    because the read can return an error I should have handled

=== The `:=` symbol

The `:=` symbol is called _short variable declaration_,
it triggers type inference so you don't have to declare the type of your local variable.
[source,go]
----
var i int = 12
i := 12
----
Both variable declaration are the same.

I just wonder why there is a special symbol for that, even if I found it very practical.
At first, I thought it was to tell apart assignment from comparison (`==`) like in Pascal.

=== Packages and imports

I wonder why imported packages are strings wrapped by double quotes:
[source,go]
----
import "fmt"
----

Then, when there are subpackages, only the last part of the package is used in the code:
[source,go]
----
include::{source_dir}/demo/subpackage.go[tags=main]
----
<1> Notice that the imported package is named `io/ioutil` not `io/util`.
<2> To use a function in this package, I use `ioutil.Readfile` not `io/ioutil.Readfile`.

Naming a package `util`( or `common` or ...) in Go is probably a poor idea.
For instance `string/util` is conflicting with `date/util`,
unless you give an alias to the import, but it looks less convenient:
[source,go]
----
import stringutil "string/util"
----

== Conclusion

To me, the Go language is well suited for low level tools
(container orchestrators, databases, proxies...), command line utilities
as well as embedded and mobile applications.
But it is not has expressive as other languages for business applications.


